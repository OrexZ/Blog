---
title: ARM过程调用你造么？
date: 2020-05-30 21:32:15
categories: arm
tags: AAPCS
toc: true
# description: some description show on the top
# feature: http://blackshow.me/favicon.png
---



## 预热科普

首先，说说PCS（Procedure Call Standard），你可以理解为是一套完整的协议，它存在的目的就是定义函数调用过程的标准（当然这也是比较狭义的解释），之所以称为标准，就是让不同层次的设计者遵循这个套路，不要特立独行，造成各种不兼容的麻烦。

提到的不同层次的设计者至少包括：

1. 各个语言领域的设计者，虽然会根据不同的特性和适用场景来遵循不同的PCS，如：C语言的cdecl
2. 各个编译器领域的设计者，编程语言和编译器的关系不言而喻，如果没有编译器，那谁去解释语言呢？可以毫不夸张的说，PCS对于编译器的设计最为重要，不然，编译出来的’积木‘如何组在一起呢？
3. 各个cpu架构的设计者，他们根据标准设计出符合自己特性的架构规格

当然，可能还有很多组织和企业涉及到PCS，不过这里就不再扩展了。



下面说说**AAPCS** - ARM Architecture Procedure Call Standard 也就是 ARM Architecture 过程调用标准。

其实对于ARM架构来说有一系列PCS标准的，他们根据不同的设计要求而诞生，大致有这些：

1. AAPCS  > Procedure Call Standard for the  ARM Architecture (this standard). (**current standard** )
2. APCS  > ARM Procedure Call Standard  (**obsolete**).
3. ATPCS > ARM-Thumb Procedure Call Standard
4. TPCS > Thumb Procedure Call Standard

闲聊到这里，接下来按照以往的惯例引出本文重点讲述的话题。



## 将要讨论的话题

前文已经有所揭示，本文不是AAPCS的解释或者翻译（想得美），重点要说明的是ARM架构中需要遵循的过程调用，抛出问题然后解答是一个比较容易实现的论述方法，对于技术类文章可以更好的帮助读者理解。

不过，不管讨论什么问题，都要有一个基础的环境，比较形象的说法是上下文：

1. 基于ARM 32bit体系结构
2. 编译代码使用交叉编译器（host x64，target arm32）

讨论的问题：

1. 调用惯例涉及到哪些方面？
2. 过程调用的基础为什么是栈？
3. 过程调用的标准流程是什么样的？
4. 如何通过示例验证前文所述内容？

后文的相关章节会一一回答这些问题。



### 过程调用涉及的方面

一般一个PCS都会定义如下的几个方面：

1. 函数参数的传递顺序和方式
2. 栈的维护方式
3. 名字修饰的策略



对于函数参数的传递顺序和方式，它说明函数使用什么介质传递参数，是完全使用栈来传递还是利用部分寄存器来实现，并且说明参数入栈或者入寄存器的顺序，从左至右或者反过来，利用寄存器的时候，参数存储的顺序等。



对于栈的维护方式，它说明是谁来完成栈的入栈和出栈操作，调用函数还是被调用函数都可以，不过只要定下来，就要一直遵循这个约定。



对于名字修饰的策略，它说明不同的PCS对函数名字的修饰方法是不一样的，之所以修饰函数名字一方面是为了编译和连接器来区分不同的调用惯例，毕竟遵循不同PCS的函数不能混用不是么？另一方面函数名字的修饰有利于高级语言实现重载等高级特性，这里就不展开了。



那么重点来了，对于ARM架构，你需要知道它是这样的：

1. 函数参数的传递顺序和方式：利用r0-r3四个寄存器按顺序存储前四个参数，其他多余的参数用栈传递，方向是从右到左
2. 栈的维护方式：由调用函数维护，而不是被调用函数（想想为什么这么写）
3. 名字修饰的策略：默认使用cdecl标准，也就是函数名字前面加下划线，不过需要验证？？？



### 必不可少的栈

对于栈，大部分同学都很熟悉，没错它是一种数据结构

1. 以存储介质（内存等）为载体，虚拟出来一个类似容器的东东
2. 特性：先入栈的数据，后出栈；想象一下电影里面的弹夹和子弹
3. 压栈操作使得栈容量增加，弹出操作使得栈容量减少

栈的设计实现有很多种方法，思考如下问题：

1. 栈的生长方向问题，是向上增长还是向下增长？
   1. 向上增长，意味着在存储介质上是向高地址空间增长的，记为A
   2. 向下增长，意味着在存储介质上是向低地址空间增长的，记为B
2. 栈的空和满状态如何设计？
   1. 满堆栈，就是栈指针指向堆栈的最后一个（栈顶）已经使用的地址，记为F
   2. 空堆栈，就是栈指针指向堆栈的第一个（基于栈顶）没有使用的地址，记为E



通过思考上述问题后，可以得出，栈的数据实现可以有四种情况：

FA，FD，EA，ED

(其实，哪种都可以满足，但对于一个体系结构，使用一种统一的方式肯定是最好的)



根据AAPCS和ATPCS的描述，可以知道，ARM体系结构栈被定义为：

递减式满堆栈 -- FD



熟悉ARM汇编指令集的同学可能知道，确定FD很重要，因为对于ARM体系结构来说，它并没有实现push和pop的指令（Thumb除外，本文不讨论Thumb），而是通过多寄存器操作指令：load-store来完成栈结构的操作。

对于load-store指令有很多的变种，当确定FD之后，那么以后在编程的时候，就知道使用的是以FD为后缀的load-store指令变种，关于ARM汇编指令，后续有会相关的文章讲解，这里不做细述。



栈的内容差不多说完了，不过这和过程调用有什么关系？

其实，如果没有栈的存在，那么就不会存在C语言中的函数调用，这个数据结构是经过前人一代代验证、更迭与实践，最后确定的数据结构，它的发展史如果你感兴趣可以取查查。

在过程调用的时候，利用栈保存了很多东西，看看大致有什么：

1. 调用函数的返回地址和需要传递给被调用函数的参数
2. 临时变量，它包括函数内部的非静态局部变量（想想为什么不用释放非静态局部变量）和编译器自动生成的其他临时变量（在讨论函数返回大数据结构时，会深刻体会到）
3. 保存上一个调用者的上下文环境，包括函数调用前后，需要保持不变的寄存器或者其他的数据















-----

功夫再好不防滑，舌头粘铁拔不下。

